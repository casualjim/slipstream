# SQLx + Migrations + Restate Microservice Subcrate — Prompt Template

<task>
{{argument_1}}
</task>

<purpose>
Initialize a new microservice subcrate configured with SQLx (online verification), forward-only migrations, a Restate service implementation, a cargo-chef Dockerfile, and a RestateDeployment manifest. All code and manifests below are examples: adapt them precisely to the details in {{argument_1}} (e.g., subcrate/package name, image name, paths, namespaces).
</purpose>

<constraints>
- Database: Postgres + TimescaleDB
- Extensions: enable timescaledb and pg_uuidv7 in the first migration
- Identifiers: UUID v7 only (SQL DEFAULT uuid_generate_v7(); Rust Uuid::now_v7())
- SQLx: online verification only (no sqlx-data.json); cargo check must require a reachable DATABASE_URL
- Queries: externalized under queries/; use query_file!/query_file_as! only; no inline SQL
- Build: build.rs must watch migrations/ and queries/**
- Layering: handlers validate; services orchestrate; repositories do DB only
- Time: use jiff from workspace for domain time; repos convert to/from DB encodings
- Async: never use std::sync::RwLock in async paths
- Single path: fail hard; no fallbacks
</constraints>

<minimal_structure>
subcrate/
  Cargo.toml
  build.rs
  .env.example
  .envrc
  migrations/
    20250101010101_init.sql
  queries/
    domain/
      example.sql
  src/
    lib.rs
    handler/
    service/
    repo/
    tests/
</minimal_structure>

<dependencies>
Use workspace dependencies where available; add SQLx explicitly in the subcrate to control features.

```toml path=null start=null
[package]
name = "my-service"        # replace with the subcrate/package name from {{argument_1}}
version.workspace = true
edition.workspace = true

[dependencies]
sqlx = { version = "0.8.6", features = [
  "postgres",
  "macros",
  "runtime-tokio-rustls",
  "json",
  "uuid",
] }

# Workspace deps
uuid.workspace = true
jiff.workspace = true
thiserror.workspace = true
tracing.workspace = true
serde.workspace = true
schemars.workspace = true
restate-sdk.workspace = true
restate-sdk-shared-core.workspace = true
workspace-hack.workspace = true
# runtime
tokio.workspace = true
```
</dependencies>

<build_script>
```rust path=null start=null
// generated by `sqlx migrate build-script`
fn main() {
  println!("cargo:rerun-if-changed=migrations");
  println!("cargo:rerun-if-changed=queries/**/*.sql");
}
```
</build_script>

<hakari>
This workspace uses cargo-hakari to unify features and speed up compilation.
- Depend on workspace-hack in the new subcrate: workspace-hack.workspace = true
- After adding/changing dependencies:
  - Using mise tasks (preferred):
    ```bash path=null start=null
    mise run hakari:generate
    mise run hakari:manage-deps
    ```
  - Or directly:
    ```bash path=null start=null
    cargo hakari generate
    cargo hakari manage-deps --yes
    ```
- Keep resolver = 3; do not alter .config/hakari.toml
- Commit workspace-hack/ changes and any Cargo.toml updates
</hakari>

<environment>
- .env.example (service-scoped URL):
```bash path=null start=null
SERVICE_DATABASE_URL="postgres://user:pass@localhost:5432/my_service_db"  # replace per {{argument_1}}
```
- .envrc (maps DATABASE_URL for SQLx):
```bash path=null start=null
# shell=bash
dotenv_if_exists .env
export DATABASE_URL="$SERVICE_DATABASE_URL"
export DBMIGRATE_URL="$SERVICE_DATABASE_URL"
export DBMIGRATE_PATH="$(pwd)/migrations"
```
</environment>

<migration>
Enable required extensions in the first migration.
```sql path=null start=null
-- migrations/20250101010101_init.sql
CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;
CREATE EXTENSION IF NOT EXISTS pg_uuidv7 CASCADE;
```
</migration>

<library_scaffolding>
Error type, DB connect helper, and a minimal Restate service bound into an Endpoint.
```rust path=null start=null
pub use error::Error;
pub type Result<T, E = Error> = core::result::Result<T, E>;

mod error {
  use thiserror::Error;

  #[derive(Debug, Error)]
  pub enum Error {
    #[error("database: {0}")]
    Db(#[from] sqlx::Error),
    #[error("io: {0}")]
    Io(#[from] std::io::Error),
    #[error("{0}")]
    Msg(String),
  }
}

use sqlx::{postgres::PgPoolOptions, PgPool};
use std::sync::Arc;

pub async fn connect(database_url: &str) -> Result<PgPool> {
  let pool = PgPoolOptions::new()
    .max_connections(10)
    .acquire_timeout(std::time::Duration::from_secs(5))
    .connect(database_url)
    .await?;
  Ok(pool)
}

use restate_sdk::prelude::*;

#[derive(Clone)]
pub struct MyServiceImpl {
  pub pool: Arc<PgPool>,
}

#[restate_sdk::service]
pub trait MyService {
  async fn ping() -> Result<String, HandlerError>;
}

impl MyService for MyServiceImpl {
  async fn ping(&self, _ctx: Context<'_>) -> Result<String, HandlerError> {
    Ok("pong".into())
  }
}

pub fn restate_endpoint(service: MyServiceImpl) -> restate_sdk::endpoint::Endpoint {
  restate_sdk::endpoint::Endpoint::builder()
    .bind(service.serve())
    .build()
}
```
</library_scaffolding>

<queries_example>
```sql path=null start=null
-- queries/domain/example.sql
SELECT 1 AS value;
```
```rust path=null start=null
#[derive(sqlx::FromRow, Debug)]
struct One { value: i32 }

pub async fn one(pool: &sqlx::PgPool) -> Result<i32> {
  let row = sqlx::query_file_as!(One, "queries/domain/example.sql")
    .fetch_one(pool)
    .await?;
  Ok(row.value)
}
```
</queries_example>

<containerization>
Create a Dockerfile in the subcrate root. Set BIN to the subcrate package name from {{argument_1}}.
```dockerfile path=null start=null
FROM lukemathwalker/cargo-chef:latest-rust-1.89 AS chef
WORKDIR /app

FROM chef AS chef-deps
RUN apt-get update && apt-get install -y --no-install-recommends \
  build-essential cmake pkg-config clang protobuf-compiler libprotobuf-dev \
  && rm -rf /var/lib/apt/lists/*

FROM chef-deps AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

FROM chef-deps AS cacher
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json --workspace

FROM chef-deps AS builder
COPY . .
COPY --from=cacher /app/target /app/target
ARG BIN=my-service
RUN cargo build --release --package ${BIN}
RUN cp target/release/${BIN} /bin/app

FROM debian:bookworm-slim AS runtime
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates \
  && rm -rf /var/lib/apt/lists/*
ENV RUST_LOG=info
RUN useradd -m -u 10001 appuser
COPY --from=builder /bin/app /usr/local/bin/app
USER appuser
EXPOSE 9080
ENTRYPOINT ["/usr/local/bin/app"]
```
Build:
```bash path=null start=null
docker build -t ghcr.io/ORG/REPO/my-service:latest --build-arg BIN=my-service .
```
</containerization>

<kubernetes>
Deploy via RestateDeployment; replace placeholders from {{argument_1}}.
```yaml path=null start=null
apiVersion: v1
kind: Namespace
metadata:
  name: my-service
  labels:
    allow.restate.dev/restate-dev: "true"
    allow.restate.dev/reachable: "true"
---
apiVersion: restate.dev/v1beta1
kind: RestateDeployment
metadata:
  name: my-service
  namespace: my-service
spec:
  replicas: 1
  restate:
    register:
      cluster: restate-dev
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
        restate.dev/handler: "true"
    spec:
      containers:
        - name: app
          image: ghcr.io/ORG/REPO/my-service:latest
          imagePullPolicy: IfNotPresent
          ports:
            - name: restate
              containerPort: 9080
          resources:
            requests:
              cpu: "50m"
              memory: "64Mi"
            limits:
              cpu: "250m"
              memory: "128Mi"
```
</kubernetes>

<execution>
- Ensure Postgres is reachable and SERVICE_DATABASE_URL is set
- Apply migrations: sqlx migrate run
- cargo check (DATABASE_URL must be set)
- Build container with --build-arg BIN=<subcrate>
- Deploy RestateDeployment and verify Ready + registration
</execution>

<acceptance>
- cargo check fails if DATABASE_URL is missing/unreachable
- build.rs rebuilds on migrations/ and queries/** changes
- First migration enables timescaledb and pg_uuidv7; IDs default uuid_generate_v7()
- All SQL in queries/; query_file*/ macros only
- Layering honored; jiff used for domain time; conversions in repos
</acceptance>

<do_dont>
Do:
- Keep single path; keep answers concise
- Use required code block metadata
Don’t:
- Use sqlx-data.json, inline SQL, or std::sync::RwLock in async
- Add fallback branches or optional starter resources
</do_dont>
