use crate::nodes::Concept;
use slipstream_store::{DatabaseCommand, DatabaseOperation, ToDatabase};
use std::sync::Arc;

/// Command to save a concept to both databases
pub struct SaveConcept {
  pub concept: Arc<Concept>,
  pub embedding_dimensions: i32,
}

impl DatabaseCommand for SaveConcept {
  type Output = ();
  type SaveData = Concept;

  fn to_operation(&self) -> DatabaseOperation<Self::Output, Self::SaveData> {
    DatabaseOperation::Mutation(slipstream_store::MutationOperation::Single {
      table: Concept::meta_table_name(),
      data: self.concept.clone(),
      graph_context: (),
      meta_context: self.embedding_dimensions,
      cypher: r#"
        MERGE (n:Concept {uuid: $uuid})
        SET n.name = $name,
            n.group_id = $group_id,
            n.created_at = $created_at
      "#,
      transformer: Box::new(slipstream_store::transformers::common::unit_result()),
    })
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::{
    migrations::concept_migration::RunConceptMigration,
    queries::get_concept_by_uuid::GetConceptByUuid,
  };
  use futures::StreamExt;
  use jiff::Timestamp;
  use slipstream_store::Database;
  use std::collections::HashMap;
  use uuid::Uuid;

  #[tokio::test]
  async fn test_save_concept() {
    // Create an in-memory test engine
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    db.execute(RunConceptMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    // Create a test concept
    let test_uuid = Uuid::now_v7();
    let now = Timestamp::now();

    let concept = Concept {
      uuid: test_uuid,
      name: "Test Concept".to_string(),
      labels: vec!["Concept".to_string(), "TestType".to_string()],
      attributes: HashMap::from([
        ("key1".to_string(), serde_json::json!("value1")),
        ("key2".to_string(), serde_json::json!(42)),
      ]),
      group_id: "test-group".to_string(),
      created_at: now,
      name_embedding: None, // Embedding will be generated by LanceDB
      summary: "A test concept for testing save functionality".to_string(),
    };

    // Save the concept
    let save_result = db
      .execute(SaveConcept {
        concept: Arc::new(concept.clone()),
        embedding_dimensions: config.embedding.dimensions,
      })
      .await;
    assert!(
      save_result.is_ok(),
      "Failed to save concept: {:?}",
      save_result.err()
    );

    // Verify we can retrieve it
    let mut get_stream = db
      .execute(GetConceptByUuid(test_uuid))
      .await
      .expect("Failed to get saved concept");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get concept from stream");

    assert_eq!(retrieved.uuid, concept.uuid);
    assert_eq!(retrieved.name, concept.name);
    assert_eq!(retrieved.labels, concept.labels);
    assert_eq!(retrieved.attributes, concept.attributes);
    assert_eq!(retrieved.group_id, concept.group_id);
  }

  #[tokio::test]
  async fn test_save_concept_upsert() {
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    db.execute(RunConceptMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    let test_uuid = Uuid::now_v7();
    let now = Timestamp::now();

    // First save
    let concept1 = Concept {
      uuid: test_uuid,
      name: "Original Concept".to_string(),
      labels: vec!["Concept".to_string()],
      attributes: HashMap::from([("version".to_string(), serde_json::json!(1))]),
      group_id: "test-group".to_string(),
      created_at: now,
      name_embedding: None,
      summary: "Original summary".to_string(),
    };

    db.execute(SaveConcept {
      concept: Arc::new(concept1),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save first concept");

    // Second save with same UUID (should update)
    let concept2 = Concept {
      uuid: test_uuid,
      name: "Updated Concept".to_string(),
      labels: vec!["Concept".to_string(), "Updated".to_string()],
      attributes: HashMap::from([("version".to_string(), serde_json::json!(2))]),
      group_id: "test-group".to_string(),
      created_at: now,
      name_embedding: None,
      summary: "Updated summary".to_string(),
    };

    db.execute(SaveConcept {
      concept: Arc::new(concept2.clone()),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save updated concept");

    // Verify the concept was updated (not duplicated)
    let mut get_stream = db
      .execute(GetConceptByUuid(test_uuid))
      .await
      .expect("Failed to get updated concept");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get concept from stream");

    assert_eq!(retrieved.name, "Updated Concept");
    assert_eq!(
      retrieved.labels,
      vec!["Concept".to_string(), "Updated".to_string()]
    );
    assert_eq!(
      retrieved.attributes.get("version"),
      Some(&serde_json::json!(2))
    );
  }

  #[tokio::test]
  async fn test_save_concept_with_complex_attributes() {
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    db.execute(RunConceptMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    let test_uuid = Uuid::now_v7();

    // Create concept with complex nested attributes
    let concept = Concept {
      uuid: test_uuid,
      name: "Complex Concept".to_string(),
      labels: vec!["Concept".to_string(), "Person".to_string()],
      attributes: HashMap::from([
        ("age".to_string(), serde_json::json!(30)),
        (
          "address".to_string(),
          serde_json::json!({
            "street": "123 Main St",
            "city": "Anytown",
            "zip": "12345"
          }),
        ),
        (
          "skills".to_string(),
          serde_json::json!(["Rust", "Python", "JavaScript"]),
        ),
        ("active".to_string(), serde_json::json!(true)),
        ("salary".to_string(), serde_json::json!(75000.50)),
      ]),
      group_id: "test-group".to_string(),
      created_at: Timestamp::now(),
      name_embedding: None,
      summary: "A person with complex attributes".to_string(),
    };

    db.execute(SaveConcept {
      concept: Arc::new(concept.clone()),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save complex concept");

    // Verify complex attributes round-trip correctly
    let mut get_stream = db
      .execute(GetConceptByUuid(test_uuid))
      .await
      .expect("Failed to get complex concept");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get concept from stream");

    assert_eq!(retrieved.attributes.len(), 5);
    assert_eq!(
      retrieved.attributes.get("age"),
      Some(&serde_json::json!(30))
    );
    assert_eq!(
      retrieved.attributes.get("active"),
      Some(&serde_json::json!(true))
    );
    assert_eq!(
      retrieved.attributes.get("salary"),
      Some(&serde_json::json!(75000.50))
    );

    // Verify nested objects
    let address = retrieved.attributes.get("address").unwrap();
    assert_eq!(address["street"], serde_json::json!("123 Main St"));
    assert_eq!(address["city"], serde_json::json!("Anytown"));
    assert_eq!(address["zip"], serde_json::json!("12345"));

    // Verify arrays
    let skills = retrieved.attributes.get("skills").unwrap();
    assert_eq!(skills, &serde_json::json!(["Rust", "Python", "JavaScript"]));
  }
}
