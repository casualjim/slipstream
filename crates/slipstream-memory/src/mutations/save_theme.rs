use crate::nodes::Theme;
use slipstream_store::{DatabaseCommand, DatabaseOperation, ToDatabase};
use std::sync::Arc;

/// Command to save a theme to both databases
pub struct SaveTheme {
  pub theme: Arc<Theme>,
  pub embedding_dimensions: i32,
}

impl DatabaseCommand for SaveTheme {
  type Output = ();
  type SaveData = Theme;

  fn to_operation(&self) -> DatabaseOperation<Self::Output, Self::SaveData> {
    DatabaseOperation::Mutation(slipstream_store::MutationOperation::Single {
      table: Theme::meta_table_name(),
      data: self.theme.clone(),
      graph_context: (),
      meta_context: self.embedding_dimensions,
      cypher: r#"
        MERGE (n:Theme {uuid: $uuid})
        SET n.group_id = $group_id,
            n.created_at = $created_at
      "#,
      transformer: Box::new(slipstream_store::transformers::common::unit_result()),
    })
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::{migrations::RunThemeMigration, queries::GetThemeByUuid};
  use futures::StreamExt;
  use jiff::Timestamp;
  use slipstream_store::Database;
  use uuid::Uuid;

  #[tokio::test]
  async fn test_save_theme() {
    // Create an in-memory test engine
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    // Run migrations to create schema
    db.execute(RunThemeMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    // Create a test theme
    let test_uuid = Uuid::now_v7();
    let now = Timestamp::now();

    let theme = Theme {
      uuid: test_uuid,
      name: "Test Theme".to_string(),
      summary: "A test theme for testing save functionality".to_string(),
      group_id: "test-group".to_string(),
      labels: vec!["Theme".to_string(), "TestType".to_string()],
      created_at: now,
      name_embedding: None, // Embedding will be generated by LanceDB
    };

    // Save the theme
    let save_result = db
      .execute(SaveTheme {
        theme: Arc::new(theme.clone()),
        embedding_dimensions: config.embedding.dimensions,
      })
      .await;
    assert!(
      save_result.is_ok(),
      "Failed to save theme: {:?}",
      save_result.err()
    );

    // Verify we can retrieve it
    let mut get_stream = db
      .execute(GetThemeByUuid(test_uuid))
      .await
      .expect("Failed to get saved theme");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get theme from stream");

    assert_eq!(retrieved.uuid, theme.uuid);
    assert_eq!(retrieved.name, theme.name);
    assert_eq!(retrieved.summary, theme.summary);
    assert_eq!(retrieved.labels, theme.labels);
    assert_eq!(retrieved.group_id, theme.group_id);
  }

  #[tokio::test]
  async fn test_save_theme_upsert() {
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    db.execute(RunThemeMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    let test_uuid = Uuid::now_v7();
    let now = Timestamp::now();

    // First save
    let theme1 = Theme {
      uuid: test_uuid,
      name: "Original Theme".to_string(),
      summary: "Original summary".to_string(),
      group_id: "test-group".to_string(),
      labels: vec!["Theme".to_string()],
      created_at: now,
      name_embedding: None,
    };

    db.execute(SaveTheme {
      theme: Arc::new(theme1),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save first theme");

    // Second save with same UUID (should update)
    let theme2 = Theme {
      uuid: test_uuid,
      name: "Updated Theme".to_string(),
      summary: "Updated summary with more details".to_string(),
      group_id: "test-group".to_string(),
      labels: vec!["Theme".to_string(), "Updated".to_string()],
      created_at: now,
      name_embedding: None,
    };

    db.execute(SaveTheme {
      theme: Arc::new(theme2.clone()),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save updated theme");

    // Verify the theme was updated (not duplicated)
    let mut get_stream = db
      .execute(GetThemeByUuid(test_uuid))
      .await
      .expect("Failed to get updated theme");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get theme from stream");

    assert_eq!(retrieved.name, "Updated Theme");
    assert_eq!(retrieved.summary, "Updated summary with more details");
    assert_eq!(
      retrieved.labels,
      vec!["Theme".to_string(), "Updated".to_string()]
    );
  }

  #[tokio::test]
  async fn test_save_theme_with_long_summary() {
    let data_dir = tempfile::tempdir().unwrap().keep();
    let config = slipstream_store::Config::new_test(data_dir);
    let db = Database::new(&config).await.unwrap();

    db.execute(RunThemeMigration {
      embedding_function_name: config.embedding.provider.clone(),
    })
    .await
    .expect("Failed to run migrations");

    let test_uuid = Uuid::now_v7();

    // Create theme with a long summary
    let theme = Theme {
      uuid: test_uuid,
      name: "Complex Theme".to_string(),
      summary: "This is a very detailed theme summary that contains comprehensive information about the theme's purpose, scope, and relationships. It includes multiple sentences describing various aspects of the theme, its importance in the knowledge graph, and how it relates to other concepts and entities. The summary is designed to be thorough and informative, providing context for anyone who needs to understand this theme's role in the system.".to_string(),
      group_id: "test-group".to_string(),
      labels: vec!["Theme".to_string(), "Complex".to_string(), "Detailed".to_string()],
      created_at: Timestamp::now(),
      name_embedding: None,
    };

    db.execute(SaveTheme {
      theme: Arc::new(theme.clone()),
      embedding_dimensions: config.embedding.dimensions,
    })
    .await
    .expect("Failed to save complex theme");

    // Verify complex theme round-trips correctly
    let mut get_stream = db
      .execute(GetThemeByUuid(test_uuid))
      .await
      .expect("Failed to get complex theme");

    let retrieved = get_stream
      .next()
      .await
      .expect("Stream should have an item")
      .expect("Failed to get theme from stream");

    assert_eq!(retrieved.summary.len(), theme.summary.len());
    assert_eq!(retrieved.summary, theme.summary);
    assert_eq!(retrieved.labels.len(), 3);
  }
}
