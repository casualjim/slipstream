//! Session management for message aggregation and usage tracking
//!
//! This module provides functionality for managing the runtime state of message processing,
//! including message aggregation, forking, and joining of message streams, as well as usage tracking.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::{Message, ModelMessage, Request, Response};

/// Tracks token consumption across different aspects of AI model interactions.
/// It provides detailed breakdowns of token usage for both prompts and completions,
/// which is essential for monitoring costs and optimizing resource usage.
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct Usage {
  /// Number of tokens in the generated completion.
  #[serde(default)]
  pub completion_tokens: i64,
  /// Number of tokens in the prompt.
  #[serde(default)]
  pub prompt_tokens: i64,
  /// Total number of tokens used in the request (prompt + completion).
  #[serde(default)]
  pub total_tokens: i64,
  /// Breakdown of tokens used in a completion.
  #[serde(default)]
  pub completion_tokens_details: CompletionTokensDetails,
  /// Breakdown of tokens used in the prompt.
  #[serde(default)]
  pub prompt_tokens_details: PromptTokensDetails,
}

impl Usage {
  /// Combines the token counts from another Usage instance with this one.
  /// This is useful for aggregating usage across multiple interactions or turns in
  /// a conversation.
  ///
  /// The method safely handles None inputs and updates all token counts and details.
  /// It's particularly useful for:
  ///   - Tracking cumulative usage across conversation turns
  ///   - Aggregating usage across multiple model calls
  ///   - Maintaining usage statistics for billing purposes
  pub fn add_usage(&mut self, usage: &Usage) {
    self.completion_tokens += usage.completion_tokens;
    self.prompt_tokens += usage.prompt_tokens;
    self.total_tokens += usage.total_tokens;
    self
      .completion_tokens_details
      .add_usage(&usage.completion_tokens_details);
    self
      .prompt_tokens_details
      .add_usage(&usage.prompt_tokens_details);
  }
}

/// Provides a detailed breakdown of token usage in model completions.
/// This structure is particularly important for understanding how tokens are being used
/// across different aspects of model output, including predictions and reasoning.
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct CompletionTokensDetails {
  /// When using Predicted Outputs, the number of tokens in the prediction that
  /// appeared in the completion.
  #[serde(default)]
  pub accepted_prediction_tokens: i64,
  /// Audio input tokens generated by the model.
  #[serde(default)]
  pub audio_tokens: i64,
  /// Tokens generated by the model for reasoning.
  #[serde(default)]
  pub reasoning_tokens: i64,
  /// When using Predicted Outputs, the number of tokens in the prediction that did
  /// not appear in the completion. However, like reasoning tokens, these tokens are
  /// still counted in the total completion tokens for purposes of billing, output,
  /// and context window limits.
  #[serde(default)]
  pub rejected_prediction_tokens: i64,
}

impl CompletionTokensDetails {
  /// Combines token counts from another CompletionTokensDetails instance.
  /// This method is used internally by Usage::add_usage to maintain accurate token
  /// counts across all completion aspects.
  pub fn add_usage(&mut self, details: &CompletionTokensDetails) {
    self.accepted_prediction_tokens += details.accepted_prediction_tokens;
    self.audio_tokens += details.audio_tokens;
    self.reasoning_tokens += details.reasoning_tokens;
    self.rejected_prediction_tokens += details.rejected_prediction_tokens;
  }
}

/// Tracks token usage specifically for prompt inputs.
/// It separates tokens used for audio inputs and cached content, which is
/// useful for optimizing prompt construction and monitoring caching efficiency.
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct PromptTokensDetails {
  /// Audio input tokens present in the prompt.
  #[serde(default)]
  pub audio_tokens: i64,
  /// Cached tokens present in the prompt.
  #[serde(default)]
  pub cached_tokens: i64,
}

impl PromptTokensDetails {
  /// Combines token counts from another PromptTokensDetails instance.
  /// This method is used internally by Usage::add_usage to maintain accurate
  /// token counts for prompt-related usage.
  pub fn add_usage(&mut self, details: &PromptTokensDetails) {
    self.audio_tokens += details.audio_tokens;
    self.cached_tokens += details.cached_tokens;
  }
}

/// Represents a collection of model messages that can be processed together.
/// It provides a type-safe way to handle multiple messages while maintaining their order.
pub type AggregatedMessages = Vec<Message<ModelMessage>>;

/// Manages a collection of messages and their associated usage statistics.
/// It supports fork-join operations to allow parallel processing of message streams
/// while maintaining message order and proper usage tracking.
#[derive(Debug, Clone)]
pub struct Aggregator {
  id: Uuid,
  messages: AggregatedMessages,
  init_len: usize,
  usage: Usage,
}

impl Default for Aggregator {
  fn default() -> Self {
    Self::new()
  }
}

impl Aggregator {
  /// Creates and initializes a new Aggregator instance.
  /// It sets up:
  /// - A new unique identifier
  /// - An empty message collection
  /// - Zero-initialized usage statistics
  pub fn new() -> Self {
    Self {
      id: Uuid::now_v7(),
      messages: Vec::new(),
      init_len: 0,
      usage: Usage::default(),
    }
  }

  /// Returns the unique identifier of this aggregator.
  /// This ID is generated when the aggregator is created or forked.
  pub fn id(&self) -> Uuid {
    self.id
  }

  /// Returns the total number of messages currently held by the aggregator.
  pub fn len(&self) -> usize {
    self.messages.len()
  }

  /// Returns true if the aggregator contains no messages.
  pub fn is_empty(&self) -> bool {
    self.messages.is_empty()
  }

  /// Returns the number of messages added to the aggregator since it was forked.
  pub fn turn_len(&self) -> usize {
    self.messages.len() - self.init_len
  }

  /// Returns a copy of all messages in the aggregator.
  /// The returned slice is a deep copy, so modifications to it won't affect
  /// the original messages in the aggregator.
  pub fn messages(&self) -> AggregatedMessages {
    self.messages.clone()
  }

  /// Returns an iterator over all messages in the aggregator.
  /// This provides a memory-efficient way to process messages sequentially
  /// without creating a copy of the entire message slice.
  pub fn messages_iter(&self) -> impl Iterator<Item = &Message<ModelMessage>> {
    self.messages.iter()
  }

  /// Returns an iterator over all but the last message in the aggregator
  /// and a reference to the last message.
  pub fn history_iter_and_last_message(
    &self,
  ) -> (
    Box<dyn Iterator<Item = &Message<ModelMessage>> + '_>,
    Option<&Message<ModelMessage>>,
  ) {
    if self.messages.is_empty() {
      return (Box::new(std::iter::empty()), None);
    }

    let last_idx = self.messages.len() - 1;
    (
      Box::new(self.messages[..last_idx].iter()),
      self.messages.last(),
    )
  }

  /// Adds any message type to the aggregator.
  /// This is a generic function that can handle any valid message type in the system.
  pub fn add_message(&mut self, message: Message<ModelMessage>) {
    self.messages.push(message);
  }

  /// Adds a user message request to the aggregator.
  /// This is typically used for adding messages that represent user input or queries.
  pub fn add_user_prompt(&mut self, message: Message<Request>) {
    if let Request::User(user_msg) = message.payload {
      self.add_message(Message {
        run_id: message.run_id,
        turn_id: message.turn_id,
        payload: ModelMessage::Request(Request::User(user_msg)),
        sender: message.sender,
        timestamp: message.timestamp,
        meta: message.meta,
      });
    }
  }

  /// Adds an assistant's response message to the aggregator.
  /// This is used for messages that represent responses or outputs from the assistant.
  pub fn add_assistant_message(&mut self, message: Message<Response>) {
    if let Response::Assistant(assistant_msg) = message.payload {
      self.add_message(Message {
        run_id: message.run_id,
        turn_id: message.turn_id,
        payload: ModelMessage::Response(Response::Assistant(assistant_msg)),
        sender: message.sender,
        timestamp: message.timestamp,
        meta: message.meta,
      });
    }
  }

  /// Adds a tool call message to the aggregator.
  /// This is used when the assistant needs to invoke an external tool or service.
  pub fn add_tool_call(&mut self, message: Message<Response>) {
    if let Response::ToolCall(tool_call_msg) = message.payload {
      self.add_message(Message {
        run_id: message.run_id,
        turn_id: message.turn_id,
        payload: ModelMessage::Response(Response::ToolCall(tool_call_msg)),
        sender: message.sender,
        timestamp: message.timestamp,
        meta: message.meta,
      });
    }
  }

  /// Adds a tool's response message to the aggregator.
  /// This is used to store the results returned from external tool invocations.
  pub fn add_tool_response(&mut self, message: Message<Request>) {
    if let Request::ToolResponse(tool_response) = message.payload {
      self.add_message(Message {
        run_id: message.run_id,
        turn_id: message.turn_id,
        payload: ModelMessage::Request(Request::ToolResponse(tool_response)),
        sender: message.sender,
        timestamp: message.timestamp,
        meta: message.meta,
      });
    }
  }

  /// Returns the current usage statistics for this aggregator.
  /// This includes token counts for prompts and completions, as well as
  /// detailed breakdowns of token usage by category.
  pub fn usage(&self) -> &Usage {
    &self.usage
  }

  /// Adds usage statistics to the aggregator.
  pub fn add_usage(&mut self, usage: &Usage) {
    self.usage.add_usage(usage);
  }

  /// Creates a new aggregator that starts with a copy of the current messages.
  /// The new aggregator gets:
  /// - A new unique ID
  /// - A copy of all current messages
  /// - An init_len set to the current message count
  /// This allows for parallel processing of message streams that can be joined later.
  pub fn fork(&self) -> Self {
    Self {
      id: Uuid::now_v7(),
      messages: self.messages.clone(),
      init_len: self.messages.len(),
      usage: Usage::default(),
    }
  }

  /// Combines messages from a forked aggregator back into this one.
  /// It:
  ///   - Appends only the messages that were added to the forked aggregator after it was forked
  ///     (determined using other.init_len)
  ///   - Combines usage statistics from both aggregators
  ///
  /// The join operation maintains message order by:
  /// 1. Keeping all original messages
  /// 2. Keeping any messages added to this aggregator after the fork
  /// 3. Appending only new messages from the forked aggregator (those after other.init_len)
  pub fn join(&mut self, other: &Aggregator) {
    // When we join, we want to append only the messages that were added to other
    // after it was forked. other.init_len represents the number of messages other had
    // when it was forked, so any messages after that index are new.
    self
      .messages
      .extend_from_slice(&other.messages[other.init_len..]);
    self.usage.add_usage(&other.usage);
  }

  /// Creates a snapshot of the current aggregator state.
  /// This allows saving the current state of messages and usage statistics
  /// for later reference or restoration.
  pub fn checkpoint(&self) -> Checkpoint {
    Checkpoint {
      id: self.id,
      messages: self.messages.clone(),
      usage: self.usage.clone(),
      init_len: self.init_len,
    }
  }
}

/// Represents a snapshot of an aggregator's state at a specific point in time.
/// It contains an immutable copy of the aggregator's state, including:
/// - The unique identifier of the source aggregator
/// - A snapshot of all messages at checkpoint time
/// - The usage statistics at checkpoint time
///
/// Checkpoints are useful for:
/// - Creating save points in long-running operations
/// - Comparing states at different points in time
/// - Rolling back to previous states if needed
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Checkpoint {
  id: Uuid,
  messages: AggregatedMessages,
  usage: Usage,
  init_len: usize,
}

impl Checkpoint {
  /// Returns the unique identifier of the aggregator that created this checkpoint.
  /// This ID matches the source aggregator's ID at the time the checkpoint was created.
  pub fn id(&self) -> Uuid {
    self.id
  }

  /// Returns a copy of all messages that were present in the aggregator
  /// at the time this checkpoint was created. The returned slice is a deep copy,
  /// so modifications won't affect the checkpoint's stored messages.
  pub fn messages(&self) -> AggregatedMessages {
    self.messages.clone()
  }

  /// Returns the usage statistics that were recorded in the aggregator
  /// at the time this checkpoint was created. This includes all token counts
  /// and usage metrics up to the checkpoint time.
  pub fn usage(&self) -> &Usage {
    &self.usage
  }

  /// Merges the checkpoint's state into another aggregator.
  /// This operation:
  /// - Appends messages from the checkpoint that were added after its fork point
  /// - Combines the checkpoint's usage statistics with the target aggregator's
  ///
  /// This is useful when you want to apply a saved state to a different or
  /// new aggregator instance.
  pub fn merge_into(&self, other: &mut Aggregator) {
    other
      .messages
      .extend_from_slice(&self.messages[self.init_len..]);
    other.usage.add_usage(&self.usage);
    if other.id == Uuid::nil() {
      other.id = self.id;
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::messages::{ContentOrParts, MessageBuilder, ToolCallData};

  #[test]
  fn test_usage_add_usage() {
    let mut usage1 = Usage {
      completion_tokens: 10,
      prompt_tokens: 20,
      total_tokens: 30,
      completion_tokens_details: CompletionTokensDetails {
        reasoning_tokens: 5,
        accepted_prediction_tokens: 3,
        rejected_prediction_tokens: 2,
        audio_tokens: 0,
      },
      prompt_tokens_details: PromptTokensDetails {
        cached_tokens: 8,
        audio_tokens: 4,
      },
    };

    let usage2 = Usage {
      completion_tokens: 15,
      prompt_tokens: 25,
      total_tokens: 40,
      completion_tokens_details: CompletionTokensDetails {
        reasoning_tokens: 7,
        accepted_prediction_tokens: 4,
        rejected_prediction_tokens: 3,
        audio_tokens: 1,
      },
      prompt_tokens_details: PromptTokensDetails {
        cached_tokens: 12,
        audio_tokens: 6,
      },
    };

    usage1.add_usage(&usage2);

    assert_eq!(usage1.completion_tokens, 25);
    assert_eq!(usage1.prompt_tokens, 45);
    assert_eq!(usage1.total_tokens, 70);
    assert_eq!(usage1.completion_tokens_details.reasoning_tokens, 12);
    assert_eq!(
      usage1.completion_tokens_details.accepted_prediction_tokens,
      7
    );
    assert_eq!(
      usage1.completion_tokens_details.rejected_prediction_tokens,
      5
    );
    assert_eq!(usage1.completion_tokens_details.audio_tokens, 1);
    assert_eq!(usage1.prompt_tokens_details.cached_tokens, 20);
    assert_eq!(usage1.prompt_tokens_details.audio_tokens, 10);
  }

  #[test]
  fn test_aggregator_new() {
    let agg = Aggregator::new();
    assert_ne!(agg.id(), Uuid::nil());
    assert!(agg.is_empty());
    assert_eq!(agg.len(), 0);
    assert_eq!(agg.turn_len(), 0);
    assert_eq!(agg.usage(), &Usage::default());
  }

  #[test]
  fn test_aggregator_add_messages() {
    let mut agg = Aggregator::new();

    // Add user message
    let user_msg = MessageBuilder::new().user_prompt("Hello");
    agg.add_user_prompt(user_msg);
    assert_eq!(agg.len(), 1);

    // Add assistant message
    let assistant_msg = MessageBuilder::new().assistant_message("Hi there!");
    agg.add_assistant_message(assistant_msg);
    assert_eq!(agg.len(), 2);

    // Add tool call
    let tool_call = MessageBuilder::new().tool_call(vec![ToolCallData {
      id: "test-id".to_string(),
      name: "test-tool".to_string(),
      arguments: r#"{"arg": "value"}"#.to_string(),
    }]);
    agg.add_tool_call(tool_call);
    assert_eq!(agg.len(), 3);

    // Add tool response
    let tool_response = MessageBuilder::new().tool_response("test-id", "test-tool", "result");
    agg.add_tool_response(tool_response);
    assert_eq!(agg.len(), 4);

    // Verify messages
    let messages = agg.messages();
    assert_eq!(messages.len(), 4);
  }

  #[test]
  fn test_aggregator_fork_and_join() {
    let mut agg1 = Aggregator::new();

    // Add initial messages
    let msg1 = MessageBuilder::new().user_prompt("message 1");
    let msg2 = MessageBuilder::new().user_prompt("message 2");
    agg1.add_user_prompt(msg1);
    agg1.add_user_prompt(msg2);
    assert_eq!(agg1.len(), 2);

    // Fork
    let mut agg2 = agg1.fork();
    assert_ne!(agg1.id(), agg2.id());
    assert_eq!(agg2.len(), 2);
    assert_eq!(agg2.turn_len(), 0);

    // Add to original
    let msg3 = MessageBuilder::new().user_prompt("message 3");
    agg1.add_user_prompt(msg3);
    assert_eq!(agg1.len(), 3);

    // Add to fork
    let msg4 = MessageBuilder::new().user_prompt("message 4");
    agg2.add_user_prompt(msg4);
    assert_eq!(agg2.len(), 3);
    assert_eq!(agg2.turn_len(), 1);

    // Join
    agg1.join(&agg2);
    assert_eq!(agg1.len(), 4);

    // Verify message order
    let messages = agg1.messages();
    if let ModelMessage::Request(Request::User(user)) = &messages[0].payload {
      if let ContentOrParts::Content(s) = &user.content {
        assert_eq!(s, "message 1");
      } else {
        panic!("Expected Content variant");
      }
    }
    if let ModelMessage::Request(Request::User(user)) = &messages[1].payload {
      if let ContentOrParts::Content(s) = &user.content {
        assert_eq!(s, "message 2");
      } else {
        panic!("Expected Content variant");
      }
    }
    if let ModelMessage::Request(Request::User(user)) = &messages[2].payload {
      if let ContentOrParts::Content(s) = &user.content {
        assert_eq!(s, "message 3");
      } else {
        panic!("Expected Content variant");
      }
    }
    if let ModelMessage::Request(Request::User(user)) = &messages[3].payload {
      if let ContentOrParts::Content(s) = &user.content {
        assert_eq!(s, "message 4");
      } else {
        panic!("Expected Content variant");
      }
    }
  }

  #[test]
  fn test_aggregator_usage_tracking() {
    let mut agg1 = Aggregator::new();
    let mut agg2 = Aggregator::new();

    // Add usage to agg1
    agg1.add_usage(&Usage {
      completion_tokens: 10,
      prompt_tokens: 20,
      total_tokens: 30,
      ..Default::default()
    });

    // Add usage to agg2
    agg2.add_usage(&Usage {
      completion_tokens: 15,
      prompt_tokens: 25,
      total_tokens: 40,
      ..Default::default()
    });

    // Join and verify combined usage
    agg1.join(&agg2);
    let usage = agg1.usage();
    assert_eq!(usage.completion_tokens, 25);
    assert_eq!(usage.prompt_tokens, 45);
    assert_eq!(usage.total_tokens, 70);
  }

  #[test]
  fn test_checkpoint() {
    let mut agg = Aggregator::new();

    // Add messages
    let msg1 = MessageBuilder::new().user_prompt("message 1");
    let msg2 = MessageBuilder::new().assistant_message("response 1");
    agg.add_user_prompt(msg1);
    agg.add_assistant_message(msg2);

    // Add usage
    agg.add_usage(&Usage {
      completion_tokens: 50,
      prompt_tokens: 100,
      total_tokens: 150,
      ..Default::default()
    });

    // Create checkpoint
    let checkpoint = agg.checkpoint();
    assert_eq!(checkpoint.id(), agg.id());
    assert_eq!(checkpoint.messages().len(), 2);
    assert_eq!(checkpoint.usage().total_tokens, 150);

    // Verify checkpoint is immutable
    let msg3 = MessageBuilder::new().user_prompt("message 3");
    agg.add_user_prompt(msg3);
    assert_eq!(agg.len(), 3);
    assert_eq!(checkpoint.messages().len(), 2);
  }

  #[test]
  fn test_checkpoint_merge_into() {
    let mut source = Aggregator::new();
    source.add_user_prompt(MessageBuilder::new().user_prompt("source message"));
    source.add_usage(&Usage {
      completion_tokens: 10,
      prompt_tokens: 20,
      total_tokens: 30,
      ..Default::default()
    });

    let checkpoint = source.checkpoint();

    let mut target = Aggregator::new();
    target.add_user_prompt(MessageBuilder::new().user_prompt("target message"));
    target.add_usage(&Usage {
      completion_tokens: 5,
      prompt_tokens: 10,
      total_tokens: 15,
      ..Default::default()
    });

    checkpoint.merge_into(&mut target);

    assert_eq!(target.len(), 2);
    assert_eq!(target.usage().completion_tokens, 15);
    assert_eq!(target.usage().prompt_tokens, 30);
    assert_eq!(target.usage().total_tokens, 45);
  }

  #[test]
  fn test_history_iter_and_last_message() {
    let mut agg = Aggregator::new();

    // Empty case
    {
      let (mut iter, last) = agg.history_iter_and_last_message();
      assert!(iter.next().is_none());
      assert!(last.is_none());
    }

    // Single message
    agg.add_user_prompt(MessageBuilder::new().user_prompt("message 1"));
    {
      let (mut iter, last) = agg.history_iter_and_last_message();
      assert!(iter.next().is_none());
      assert!(last.is_some());
    }

    // Multiple messages
    agg.add_user_prompt(MessageBuilder::new().user_prompt("message 2"));
    agg.add_user_prompt(MessageBuilder::new().user_prompt("message 3"));
    {
      let (iter, last) = agg.history_iter_and_last_message();
      let history: Vec<_> = iter.collect();
      assert_eq!(history.len(), 2);
      assert!(last.is_some());
      if let Some(msg) = last {
        if let ModelMessage::Request(Request::User(user)) = &msg.payload {
          if let ContentOrParts::Content(s) = &user.content {
            assert_eq!(s, "message 3");
          } else {
            panic!("Expected Content variant");
          }
        }
      }
    }
  }

  #[test]
  fn test_checkpoint_serialization() {
    let mut agg = Aggregator::new();
    agg.add_user_prompt(MessageBuilder::new().user_prompt("test message"));
    agg.add_usage(&Usage {
      completion_tokens: 10,
      prompt_tokens: 20,
      total_tokens: 30,
      ..Default::default()
    });

    let checkpoint = agg.checkpoint();

    // Serialize
    let serialized = serde_json::to_string(&checkpoint).unwrap();

    // Deserialize
    let deserialized: Checkpoint = serde_json::from_str(&serialized).unwrap();

    assert_eq!(checkpoint.id(), deserialized.id());
    assert_eq!(checkpoint.messages().len(), deserialized.messages().len());
    assert_eq!(checkpoint.usage(), deserialized.usage());
  }
}
