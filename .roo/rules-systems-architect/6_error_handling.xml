<error_handling>
  <overview>
    Categorize errors at boundaries, propagate context, and never panic in production paths. Keep domain errors small and explicit; translate infra/driver errors at adapter boundaries. Provide enough context for operators without leaking sensitive data.
  </overview>

  <rust>
    <principles>
      <principle>No unwrap/expect in production code paths.</principle>
      <principle>Use eyre for flexible internal propagation; convert to thiserror enums at stable boundaries.</principle>
      <principle>Add context with eyre::WrapErr to pinpoint failure locations.</principle>
      <principle>Prefer Result<T, E> with small E; avoid opaque boxed errors for domain-facing APIs.</principle>
    </principles>
    <code language="rust"><![CDATA[
#[derive(Debug, thiserror::Error)]
pub enum RepoError {
    #[error("not found")]
    NotFound,
    #[error("conflict")]
    Conflict,
    #[error("storage: {0}")]
    Storage(String),
    #[error("unknown: {0}")]
    Unknown(String),
}

pub async fn load(id: &str) -> Result<Model, RepoError> {
    let row = query_one(id).await.map_err(|e| RepoError::Storage(e.to_string()))?;
    row.ok_or(RepoError::NotFound)
}
]]></code>
  </rust>

  <golang>
    <principles>
      <principle>Return errors explicitly, wrap with context using fmt.Errorf("%w").</principle>
      <principle>Use sentinel or typed errors when consumers need to branch.</principle>
      <principle>Propagate context.Context for cancellation/timeouts.</principle>
    </principles>
    <code language="go"><![CDATA[
var ErrNotFound = errors.New("not found")

func Load(ctx context.Context, id string, repo Repo) (Model, error) {
  m, err := repo.Get(ctx, id)
  if err != nil {
    if errors.Is(err, ErrNotFound) {
      return Model{}, err
    }
    return Model{}, fmt.Errorf("repo.get: %w", err)
  }
  return m, nil
}
]]></code>
  </golang>

  <typescript>
    <principles>
      <principle>Prefer tagged result types over throwing in domain core.</principle>
      <principle>Convert thrown/HTTP/IO errors at adapters; keep domain pure.</principle>
      <principle>Log at the edge; avoid logging deep in core logic.</principle>
    </principles>
    <code language="typescript"><![CDATA[
export type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };

export enum RepoErrorKind { NotFound = "NotFound", Conflict = "Conflict", Storage = "Storage", Unknown = "Unknown" }
export type RepoError = { kind: RepoErrorKind; message?: string };

export function mapInfraError(e: unknown): RepoError {
  return { kind: RepoErrorKind.Storage, message: String(e) };
}
]]></code>
  </typescript>

  <operational_guidelines>
    <logging>
      <rule>Attach minimal, useful context: ids, durations, counts; exclude sensitive values.</rule>
      <rule>Use structured logs where possible; keep log volume proportional to signal.</rule>
    </logging>
    <observability>
      <rule>Emit key counters/timers around critical paths only after need is demonstrated.</rule>
      <rule>Prefer sampling for high-volume events.</rule>
    </observability>
    <failure_modes>
      <rule>Design idempotent operations for at-least-once delivery.</rule>
      <rule>Backoff and retry with caps; surface final failures with actionable messages.</rule>
    </failure_modes>
  </operational_guidelines>
</error_handling>
