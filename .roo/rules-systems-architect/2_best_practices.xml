<best_practices>
  <general_principles>
    <principle priority="highest">
      <name>Simple over Clever</name>
      <description>Favor straightforward solutions and small surfaces that are easy to reason about. Avoid clever abstractions that hide complexity or create incidental coupling.</description>
      <rationale>Simplicity reduces defects, improves onboarding, and makes optimizations cheaper when they are actually needed.</rationale>
      <example>
        <scenario>Introduce a repository API</scenario>
        <good>Define a minimal trait/port with explicit inputs/outputs and invariants; add adapters for storage backends.</good>
        <bad>Introduce a generic, highly-parameterized abstraction with complex type gymnastics and implicit behavior.</bad>
      </example>
    </principle>

    <principle priority="high">
      <name>Design for Composition, Not Inheritance</name>
      <description>Build small, composable units with clear inputs/outputs. Prefer functions and traits with explicit capabilities over deep hierarchies.</description>
      <rationale>Composition enables incremental change and local reasoning. It limits blast radius when refactoring.</rationale>
      <example>
        <scenario>Adding an embedding step</scenario>
        <good>Provide a pure function or trait capability that receives data and returns embeddings.</good>
        <bad>Embed the behavior in a base class with hidden global state.</bad>
      </example>
    </principle>

    <principle priority="high">
      <name>Invariants First</name>
      <description>Make invariants explicit at API boundaries and encode them in types or validation functions.</description>
      <rationale>Failing fast and precisely at boundaries prevents invalid state from propagating.</rationale>
      <example>
        <scenario>ID handling</scenario>
        <good>Use newtypes and validated constructors for IDs; reject invalid inputs early.</good>
        <bad>Use bare strings everywhere and validate sporadically.</bad>
      </example>
    </principle>

    <principle priority="high">
      <name>Minimize Fan-out and Dependencies</name>
      <description>Keep module fan-out small; depend on narrow, stable interfaces.</description>
      <rationale>Reduces coupling and cost of change; improves testability and reuse.</rationale>
    </principle>

    <principle priority="medium">
      <name>Optimize with Evidence</name>
      <description>Implement the simple, correct path first; optimize only after profiling/measurement.</description>
      <rationale>Premature optimization locks in complexity and hides bugs.</rationale>
    </principle>

    <principle priority="medium">
      <name>Document Decisions with Short ADR Notes</name>
      <description>Capture key choices and tradeoffs succinctly near the code.</description>
      <rationale>Future maintainers need context for why constraints exist.</rationale>
    </principle>
  </general_principles>

  <language_specific>
    <rust>
      <guideline>Use eyre::Result in app layers; map to thiserror types at boundaries where stable error contracts are needed.</guideline>
      <guideline>No unwrap/expect in production paths. Propagate errors with context using eyre::WrapErr.</guideline>
      <guideline>Prefer small traits as ports; avoid wide traits with many optional methods.</guideline>
      <guideline>Use newtypes for IDs and strongly-typed units; prefer &str/&[u8] where borrowing is clear.</guideline>
      <guideline>Keep modules cohesive and private-by-default; expose minimal public API.</guideline>
    </rust>

    <golang>
      <guideline>Define small interfaces in the consumer package; avoid exporting broad interfaces prematurely.</guideline>
      <guideline>Propagate context.Context; timeouts/cancellation are part of the contract.</guideline>
      <guideline>Return explicit errors; wrap with context using fmt.Errorf("%w").</guideline>
      <guideline>Prefer simple data structs + functions; avoid deep embedding and hidden behavior.</guideline>
    </golang>

    <typescript>
      <guideline>Enable strict types; avoid any. Use exact object shapes and discriminated unions for variants.</guideline>
      <guideline>Validate at boundaries (e.g., zod or hand-rolled guards) and convert to domain types early.</guideline>
      <guideline>Use pure functions for transformations; avoid side effects in core domain logic.</guideline>
      <guideline>Model error results explicitly (Result<T, E>-like patterns) for domain boundaries.</guideline>
    </typescript>
  </language_specific>

  <data_store_guidance>
    <postgres>
      <use_cases>OLTP, strong consistency, relational integrity, transactional workflows.</use_cases>
      <notes>Model entities and relationships explicitly; keep migrations predictable; avoid leaky domain coupling to SQL details by isolating in adapter layer.</notes>
    </postgres>
    <lancedb>
      <use_cases>Vector search, analytics-friendly columnar storage.</use_cases>
      <notes>Keep embedding pipelines explicit; use idempotency keys for upserts; cache wisely after measuring.</notes>
    </lancedb>
    <kuzudb>
      <use_cases>Graph/relationships, traversals, knowledge networks.</use_cases>
      <notes>Encode relationships intentionally; avoid mixing traversal logic into domainâ€”expose via repository/adapter ports.</notes>
    </kuzudb>
    <integration>
      <principle>Ports and Adapters</principle>
      <rule>Define domain-facing repository traits/interfaces; provide Postgres/LanceDB/KuzuDB adapters that satisfy the same contract.</rule>
      <rule>Never leak driver types into domain. Translate at the boundary.</rule>
      <rule>Keep transactions/migrations localized to adapters and service layers, not the domain core.</rule>
    </integration>
  </data_store_guidance>

  <common_pitfalls>
    <pitfall>
      <description>Over-generalized abstractions created up front</description>
      <why_problematic>Increases incidental complexity and reduces adaptability.</why_problematic>
      <correct_approach>Start from specific use cases; abstract only what repeats twice.</correct_approach>
    </pitfall>
    <pitfall>
      <description>Test-induced design and overfitting to fixtures</description>
      <why_problematic>Yields brittle interfaces driven by test structure rather than domain needs.</why_problematic>
      <correct_approach>Write contract tests at boundaries; allow internal refactors without test churn.</correct_approach>
    </pitfall>
    <pitfall>
      <description>Leaking infra concerns into domain</description>
      <why_problematic>Ties domain to a storage or transport and hinders change.</why_problematic>
      <correct_approach>Isolate drivers with adapters; define stable domain ports.</correct_approach>
    </pitfall>
    <pitfall>
      <description>Hidden global state and implicit behavior</description>
      <why_problematic>Breaks local reasoning and reproducibility.</why_problematic>
      <correct_approach>Pass dependencies explicitly; prefer pure functions and explicit context.</correct_approach>
    </pitfall>
  </common_pitfalls>

  <quality_checklist>
    <category name="before_starting">
      <item>Write down the goal and constraints (performance, cost, operability, data guarantees).</item>
      <item>Identify domain boundaries and external concerns.</item>
      <item>Confirm minimal surface area to achieve the goal.</item>
    </category>
    <category name="during_implementation">
      <item>Keep ports small and explicit; compose small functions.</item>
      <item>Encode invariants in types or validation; fail fast at boundaries.</item>
      <item>Add contextual error handling; avoid unwrap/expect.</item>
      <item>Prefer straightforward, correct slow path; add metrics only as needed.</item>
    </category>
    <category name="before_completion">
      <item>Validate against multi-goal criteria: correctness, simplicity, cost, performance, operability, evolvability, testability.</item>
      <item>Ensure domain is storage/transport agnostic via adapters.</item>
      <item>Provide brief ADR-style rationale summarizing tradeoffs.</item>
    </category>
  </quality_checklist>
</best_practices>
