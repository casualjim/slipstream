<examples>
  <example name="storage_agnostic_repository_with_vector_index">
    <description>Introduce a storage-agnostic Interaction repository with Postgres as default and optional LanceDB vector index integration.</description>
    <context>Use when you need domain code decoupled from storage while enabling vector search features without leaking infra concerns.</context>
    <steps>
      <step>Define a minimal domain port (trait/interface) with explicit inputs/outputs and invariants.</step>
      <step>Implement a Postgres adapter for OLTP and consistency.</step>
      <step>Add an optional LanceDB adapter or companion indexer implementing a separate capability port for embeddings/vector search.</step>
      <step>Keep embedding pipeline explicit; ensure idempotency for upserts.</step>
    </steps>
    <code language="rust"><![CDATA[
// Domain port + vector search capability
#[derive(Debug, Clone)]
pub struct InteractionId(String);

#[derive(Debug, Clone)]
pub struct Interaction {
    pub id: InteractionId,
    pub content: String,
}

#[async_trait::async_trait]
pub trait InteractionRepo {
    async fn get(&self, id: &InteractionId) -> Result<Interaction, RepoError>;
    async fn upsert(&self, i: &Interaction) -> Result<(), RepoError>;
    async fn delete(&self, id: &InteractionId) -> Result<(), RepoError>;
}

// Optional capability: vector index for semantic search
#[async_trait::async_trait]
pub trait InteractionVectorIndex {
    async fn upsert_embedding(&self, id: &InteractionId, vector: &[f32]) -> Result<(), RepoError>;
    async fn search(&self, query: &[f32], top_k: usize) -> Result<Vec<InteractionId>, RepoError>;
}

// Postgres adapter implements InteractionRepo
pub struct PgInteractionRepo { /* pool: sqlx::PgPool */ }
#[async_trait::async_trait]
impl InteractionRepo for PgInteractionRepo {
    async fn get(&self, _id: &InteractionId) -> Result<Interaction, RepoError> { todo!() }
    async fn upsert(&self, _i: &Interaction) -> Result<(), RepoError> { todo!() }
    async fn delete(&self, _id: &InteractionId) -> Result<(), RepoError> { todo!() }
}

// LanceDB index implements InteractionVectorIndex
pub struct LanceInteractionIndex { /* lance handle */ }
#[async_trait::async_trait]
impl InteractionVectorIndex for LanceInteractionIndex {
    async fn upsert_embedding(&self, _id: &InteractionId, _vector: &[f32]) -> Result<(), RepoError> { todo!() }
    async fn search(&self, _query: &[f32], _top_k: usize) -> Result<Vec<InteractionId>, RepoError> { todo!() }
}

// Application service composes capabilities
pub struct InteractionService<R: InteractionRepo, V: InteractionVectorIndex> {
    repo: R,
    vectors: Option<V>,
    embed: fn(&str) -> eyre::Result<Vec<f32>>, // capability-injection for embeddings
}
impl<R: InteractionRepo, V: InteractionVectorIndex> InteractionService<R, V> {
    pub fn new(repo: R, vectors: Option<V>, embed: fn(&str) -> eyre::Result<Vec<f32>>) -> Self {
        Self { repo, vectors, embed }
    }
    pub async fn save(&self, i: Interaction) -> Result<(), RepoError> {
        eyre::ensure!(!i.content.trim().is_empty(), "empty content")
            .map_err(|e| RepoError::Unknown(e.to_string()))?;
        self.repo.upsert(&i).await?;
        if let Some(ix) = &self.vectors {
            let vec = (self.embed)(&i.content).map_err(|e| RepoError::Unknown(e.to_string()))?;
            ix.upsert_embedding(&i.id, &vec).await?;
        }
        Ok(())
    }
}
]]></code>
    <explanation>Domain remains clean via ports; adapters implement infra details. The vector index is optional and capability-based, preserving simplicity.</explanation>
    <validation>
      <check>Contract tests on InteractionRepo port</check>
      <check>Idempotent upserts with unique constraints</check>
      <check>No infra types leak into domain</check>
      <check>Performance measured before optimizing embeddings/index refresh</check>
    </validation>
  </example>

  <example name="event_bus_port_with_cf_worker_adapter">
    <description>Add a minimal event bus interface and implement a Cloudflare Worker adapter.</description>
    <context>Use for decoupled event publication where transport can vary.</context>
    <code language="typescript"><![CDATA[
export interface EventBus {
  publish(topic: string, payload: unknown): Promise<void>;
}

export class CfWorkerEventBus implements EventBus {
  constructor(private endpoint: string, private token: string) {}
  async publish(topic: string, payload: unknown): Promise<void> {
    const res = await fetch(`${this.endpoint}/topics/${encodeURIComponent(topic)}`, {
      method: "POST",
      headers: { Authorization: `Bearer ${this.token}`, "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error(`Publish failed: ${res.status}`);
  }
}
]]></code>
    <explanation>Domain depends only on EventBus port; adapter swaps without churn.</explanation>
  </example>

  <example name="extract_minimal_domain_core_from_overgrown_module">
    <description>Refactor a large module by extracting a minimal domain core and ports for IO.</description>
    <context>Use when infra concerns and domain logic are tangled.</context>
    <steps>
      <step>Identify core domain types and operations (pure functions).</step>
      <step>Define ports for storage/messaging.</step>
      <step>Move infra code behind adapters; keep domain free of driver types.</step>
      <step>Write contract tests on ports; characterization tests around legacy behavior if needed.</step>
    </steps>
  </example>
</examples>
